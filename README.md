# TransportCatalogue

## _Описание проекта:_


Учебный проект, позволяющий создать транспортный справочник автобусных маршрутов. Система работает с JSON запросами. Осуществлена сериализация справочника через протокол Protobuff. Реализована возможность отображения карты строкой в SVG формате.

##  _Развертывание проекта_
Проект реализован на С++ 17. Для запуска следует установить [Protocol Buffers v3.17.3](https://github.com/protocolbuffers/protobuf/releases "Protocol Buffers v3.17.3").
Сборка осуществляется при помощи CMake. Перед сборкой путь к установленному пакету Protobuf  указывается командой:
**`cmake . -DCMAKE_PREFIX_PATH=/path/to/protobuf/package`**

## _Форматы json запросов_
Программа работает в двух режимах **make_base** и **process_requests**.

<details><summary> Json запрос для режима make_base</summary>
  Представляет собой словарь со следующими полями:
  <details><summary>"base_requests": [ ... ], </summary>Массив base_requests содержит элементы двух типов: маршрут и остановка. Данные элементы формируют транспортный справочник. Пример json объекта, описывающего остановку:
    
    {
      "type": "Stop",
      "name": "Электросети",
      "latitude": 43.598701,
      "longitude": 39.730623,
      "road_distances":
      {
        "Улица Докучаева": 3000,
        "Улица Лизы Чайкиной": 4300
      }
    }   

Где ключи это:
- type — строка, равная "Stop", означает, что объект описывает остановку;
- name — название остановки;
- latitude и longitude задают координаты широты и долготы остановки;
- road_distances — словарь, задающий расстояние до соседних остановок. Ключ — название остановки, значение — целое число в метрах.

Пример json объекта, описывающего маршрут:
    
    {
      "type": "Bus",
      "name": "14",
      "stops": [
        "Улица Лизы Чайкиной",
        "Электросети",
        "Улица Докучаева",
        "Улица Лизы Чайкиной"
      ],
      "is_roundtrip": true
    }
  
- type — строка, равная "Bus", означающая, что объект описывает автобусный маршрут;
- name — название маршрута;
- stops — массив с названиями остановок, через которые проходит автобусный маршрут. У кольцевого маршрута название последней остановки дублирует название первой. Например ["stop1", "stop2", "stop3", "stop1"];
- is_roundtrip — значение типа bool. Указывает кольцевой маршрут или нет.
</details><details>
  <summary>"routing_settings" : [ ... ], </summary> Словарь с двумя ключами:
  
- bus_wait_time — время ожидания автобуса на остановке, в минутах;
- bus_velocity — скорость автобуса, в км/ч.
  
Пример:
  
    {
      "bus_wait_time": 6,
      "bus_velocity": 40
    }
  
</details><details>
<summary>"render_settings": { ... }</summary> Словарь с полями, описывающими параметры изображения карты. Пример:
  
    {
      "width": 1200.0,
      "height": 1200.0,
      "padding": 50.0,
      "line_width": 14.0,
      "stop_radius": 5.0,
      "bus_label_font_size": 20,
      "bus_label_offset": [7.0, 15.0],
      "stop_label_font_size": 20,
      "stop_label_offset": [7.0, -3.0],
      "underlayer_color": [255, 255, 255, 0.85],
      "underlayer_width": 3.0,
      "color_palette": [
        "green",
        [255, 160, 0],
        "red"
      ]
    }

Описание полей:
- width и height — ключи, которые задают ширину и высоту в пикселях.
- padding — отступ краёв карты от границ SVG-документа.
- line_width — толщина линий, которыми рисуются автобусные маршруты.
- stop_radius — радиус окружностей, которыми обозначаются остановки.
- bus_label_font_size — размер текста, которым написаны названия автобусных маршрутов.
- bus_label_offset — смещение надписи с названием маршрута относительно координат конечной остановки на карте;
- stop_label_font_size — размер текста, которым отображаются названия остановок.
- stop_label_offset — смещение названия остановки относительно её координат на карте.
- underlayer_color — цвет подложки под названиями остановок и маршрутов.
- underlayer_width — толщина подложки под названиями остановок и маршрутов;
- color_palette — цветовая палитра;
  </details><details><summary>"serialization_settings": {...}</summary>Cловарь с единственным ключом file, которому соответствует строка — название файла. Именно в этот файл нужно сохранить сериализованную базу. Пример:
  
    {
      "file": "transport_catalogue.db"
    }
  
  </details>
 </details>

 <details><summary>Json запрос для режима process_requests</summary>Представляет собой словарь со следующими полями:
  
 <details><summary>"stat_requests": [...]</summary> Массив запросов. Каждый элемент массива - это словарь, который обязательно имеет поле id - номер запроса и type - тип запроса. 

Запрос на получение информации об автобусном маршруте:
   
    {
      "id": 1,
      "type": "Bus",
      "name": "14"
    } 
   
Ключ name задаёт название маршрута, для которого приложение должно вывести статистическую информацию.

В ответ на этот запрос должен быть выдан ответ в виде словаря:
   
    {
      "curvature": 2.18604,
      "request_id": 12345678,
      "route_length": 9300,
      "stop_count": 4,
      "unique_stop_count": 3
    }

Где:
- curvature — число типа double, задающее извилистость маршрута. Извилистость равна отношению длины дорожного расстояния маршрута к длине географического расстояния;
- request_id — целое число, равное id соответствующего запроса Bus;
- route_length — целое число, равное длине маршрута в метрах;
- stop_count — количество остановок на маршруте;
- unique_stop_count — количество уникальных остановок на маршруте
  
Запрос на получение информации об автобусной остановке:

    {
      "id": 12345,
      "type": "Stop",
      "name": "Улица Докучаева"
    }
   
Ключ name задаёт название остановки.

В ответ на этот запрос должен быть выдан ответ в виде словаря:

   
    {
      "buses": ["14", "22к"],
      "request_id": 12345
    }

Где:
- buses — массив названий автобусных маршрутов, проходящих через эту остановку. Названия маршрутов должны быть отсортированы в лексикографическом порядке.
- request_id - целое число, равное id соответствующего запроса Stop.

   
Запрос на получение изображения карты:
   
    {
      "type": "Map",
      "id": 11111
    }
   
Ответ на запрос:
   
    {
      "map": "...",
      "request_id": 11111
    } 
   
Где map — строка с изображением карты в формате SVG.   

Запросы на построение маршрута между двумя остановками:
   
    {
      "type": "Route",
      "from": "Biryulyovo Zapadnoye",
      "to": "Universam",
      "id": 4
    }
   
Описание полей:
- from — остановка, где нужно начать маршрут;
- to — остановка, где нужно закончить маршрут.

Ответ на запрос Route устроен следующим образом:   
  
    {
      "request_id": <id запроса>,
      "total_time": <суммарное время>,
      "items": [<элементы маршрута>]
    }
   
- total_time — суммарное время в минутах, которое требуется для прохождения маршрута.
- items — список элементов маршрута, каждый из которых описывает непрерывную активность пассажира, требующую временных затрат. Элементы маршрута бывают двух типов.
   
Wait — подождать нужное количество минут на указанной остановке:
   
    {
      "type": "Wait",
      "stop_name": "Biryulyovo",
      "time": 6
    }
   
Bus — проехать span_count остановок (перегонов между остановками) на автобусе bus, потратив указанное количество минут:
   
    {
      "type": "Bus",
      "bus": "297",
      "span_count": 2,
      "time": 5.235
    } 
    
Если маршрута между указанными остановками нет, выведите результат в следующем формате:
   
    {
      "request_id": <id запроса>,
      "error_message": "not found"
    } 
   

 </details>
  <details><summary>"serialization_settings" : {...}</summary> Словарь с настройками сериализации в формате, аналогичном этой же секции на входе make_base. А именно, в ключе file указывается название файла, из которого нужно считать сериализованную базу.
  </details>
 </details> 

 
 
 Пример запроса make_base, process_requests и ответов системы на них представлены в фаилах make_base_example.json, process_requests_example.json и answer_example.json соответсвенно.
 


## _Планы по доработке:_
* обработать все warning сообщения при сборке проекта;
* разработать графический интерфейс;
* добавить визуализацию построенного маршрута;

